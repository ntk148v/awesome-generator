// Copyright (c) 2021 Kien Nguyen-Tuan <kiennt2609@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"

	"github.com/google/go-github/v33/github"
	"github.com/olekukonko/tablewriter"
	"github.com/pkg/errors"
	"golang.org/x/oauth2"
	"gopkg.in/alecthomas/kingpin.v2"
)

var (
	desc = `
# Awesome %s

[![Awesome](https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg)](https://github.com/sindresorhus/awesome)

> A curated list of awsome %s! Generated by [awesome-generator](https://github.com/ntk148v/awesome-generator)
	`
	license = `
## License

[![CC0](http://mirrors.creativecommons.org/presskit/buttons/88x31/svg/cc-zero.svg)](https://creativecommons.org/publicdomain/zero/1.0/)
To the extent possible under law, [%s](https://github.com/%s) has waived all copyright and related or neighboring rights to this work.
	`
	toc = `
## Table of Contents

  - [Awesome %s](#awesome-%s)
	`
	tocEntry = `  - [%s](#%s)
	`
	headers = []string{"Index", "Name", "Description", "Number of stars"}
)

func initGithubClient(ctx context.Context, auth Auth) (*github.Client, error) {
	if auth.AccessToken != "" {
		ts := oauth2.StaticTokenSource(
			&oauth2.Token{AccessToken: strings.TrimSpace(auth.AccessToken)},
		)
		tc := oauth2.NewClient(ctx, ts)
		return github.NewClient(tc), nil
	}

	if auth.Username != "" && auth.Password != "" {
		tp := github.BasicAuthTransport{
			Username: strings.TrimSpace(auth.Username),
			Password: strings.TrimSpace(auth.Password),
		}
		if auth.OTP != "" {
			tp.OTP = auth.OTP
		}
		return github.NewClient(tp.Client()), nil
	}

	return nil, errors.New("Invalid Github authentication configuration")
}

func fetchReposByTopics(ctx context.Context, cli *github.Client, topics []string) ([][]string, error) {
	var q string
	// construct search query
	for i, t := range topics {
		q += "topic:" + t
		if i != len(topics)-1 {
			q += " "
		}
	}
	results, _, err := cli.Search.Repositories(ctx, q, &github.SearchOptions{Sort: "stars"})
	var repos [][]string
	for i, r := range results.Repositories {
		repos = append(repos, []string{
			strconv.Itoa(i + 1), fmt.Sprintf("[%s](%s)", r.GetName(), r.GetHTMLURL()),
			r.GetDescription(), strconv.Itoa(r.GetStargazersCount()),
		})
	}
	return repos, err
}

func fetchTopic(ctx context.Context, cli *github.Client, topic string) ([]string, error) {
	results, _, err := cli.Search.Topics(ctx, topic, &github.SearchOptions{})
	// Get 1st result
	result := results.Topics[0]
	return []string{topic, result.GetDescription()}, err
}

func recordSection(topic []string, repos [][]string) string {
	section := `
## %s

%s

`
	section = fmt.Sprintf(section, strings.Title(strings.ReplaceAll(topic[0], "-", " ")),
		topic[1])
	buf := new(bytes.Buffer)
	table := tablewriter.NewWriter(buf)
	table.SetHeader(headers)
	table.SetBorders(tablewriter.Border{Left: true, Top: false, Right: true, Bottom: false})
	table.SetCenterSeparator("|")
	table.SetAutoWrapText(false)
	table.AppendBulk(repos)
	table.Render()
	section += buf.String()
	return section
}

func main() {
	var (
		cfgFile    string
		cfg        *Config
		content    string
		wg         sync.WaitGroup
		secContent string
		tocContent string
	)

	a := kingpin.New(filepath.Base(os.Args[0]), "A lazy tool written by Golang to generate a user-defined awesome currated list.")
	a.Flag("config.file", "Prom-summary configuration file path.").
		Default("etc/config.yml").StringVar(&cfgFile)

	_, err := a.Parse(os.Args[1:])
	if err != nil {
		fmt.Fprintln(os.Stderr, errors.Wrapf(err, "Error parsing commandline arguments"))
		a.Usage(os.Args[1:])
		os.Exit(2)
	}

	cfg, err = LoadFile(cfgFile)
	if err != nil {
		fmt.Fprintln(os.Stderr, errors.Wrapf(err, "Error loading configuration file"))
		os.Exit(2)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	content += fmt.Sprintf(desc, strings.Title(cfg.Topic), cfg.Topic)
	tocContent += fmt.Sprintf(toc, strings.Title(cfg.Topic), cfg.Topic)
	// Init Github client
	cli, err := initGithubClient(ctx, cfg.Auth)
	if err != nil {
		fmt.Fprintln(os.Stderr, errors.Wrapf(err, "Error initializing Github client"))
		os.Exit(2)
	}

	for _, t := range cfg.SubTopics {
		wg.Add(1)
		go func(ctx context.Context, cli *github.Client, topics []string) {
			defer wg.Done()
			repos, err := fetchReposByTopics(ctx, cli, topics)
			if err != nil {
				fmt.Fprintln(os.Stderr, errors.Wrapf(err, "Error querying Github repositotories by topic"))
				return
			}
			if len(repos) == 0 {
				return
			}
			topic, err := fetchTopic(ctx, cli, topics[1])
			if err != nil {
				fmt.Fprintln(os.Stderr, errors.Wrapf(err, "Error querying Github topic"))
				return
			}
			section := recordSection(topic, repos)
			tocContent += fmt.Sprintf(tocEntry, strings.Title(strings.ReplaceAll(topics[1], "-", " ")),
				strings.ToLower(topics[1]))
			secContent += section
		}(ctx, cli, []string{cfg.Topic, t})
	}

	wg.Wait()

	// Bring together
	content += tocContent
	content += secContent
	content += fmt.Sprintf(license, cfg.Auth.Username, cfg.Auth.Username)
	_ = ioutil.WriteFile(cfg.OutputFile, []byte(content), 0644)
}
